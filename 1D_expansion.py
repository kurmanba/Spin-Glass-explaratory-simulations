import numpy as np
from itertools import permutations
import matplotlib.pyplot as plt

""""Puropse of the work is to understand symmetry of neighbor repositioning and
    see how rules based on nearest neighbors can be extended. What we want to see 
    existence of nearest neighbor based transform so that it affects each 
    element in a same manner. """

""" This piece of code distributes original set of neighbors equidistantly from 
    each other (with an assumption of periodic boundary conditions). 
    Such oredering is generated by recursive expansion centered around each 
    element.(center can be any point achieved by circular shift) """

""" INPUT:
    ______

    n: size from which list (x_1,x_2,....x_n) is generated. Here x_1 has a 
    nearest neighbors (R: x_2, L: x_n), (R2: x_3, L2: x_n-1) and so on...

    OUTPUT: 
    _______

    List: (x_n,...) ordered in a manner that each element from original list now
    equidistantly placed from each other.

    Example: for n = 9 -> (1,2,3,4,5,6,7,8,9) is generated and output is:

    k = 1 ...  (none just rotation or mirroring of the original state)
    k = 2 ...  (1,5,9,4,8,3,7,2,6)
    k = 3 ...  (empty no symmetry found)
    k = 4 ...  (1,3,5,7,9,2,4,6,8) 

    This information will help to find partition function. """


# Helper functions: Index,Center....
def generate_distinguishable_indexes(n):
    return np.arange(0, n, 1)


def generate_neighbor_indexes_periodic(n):
    if (n % 2) == 0:
        return np.hstack((np.arange(0, (int(n / 2) + 1), 1), np.arange((int(n / 2) - 1), 0, -1)))
    else:
        return np.hstack((np.arange(0, int(n / 2) + 1, 1), np.arange((int(n / 2)), 0, -1)))


def center(list_to_be_centered, element):  # circshift to initialize list at element
    return np.roll(list_to_be_centered, -element + 1)


def access_neighbor_index(n):
    starting_list = np.arange(1, n + 1, 1)
    neighbor_struct_centered = {}
    for i, j in enumerate(starting_list):
        neighbor_struct_centered[j] = center(starting_list, j)
    return neighbor_struct_centered


def generate_instructions(working_list, neighbor_map, contradiction):
    instructions = np.zeros(n)
    flags = np.zeros(n)
    temporal = np.argwhere(working_list != 0)
    for i, j in enumerate(temporal):
        flags = center(working_list, j + 1)
        detect_transfer = np.argwhere(flags != 0)
        for m, l in enumerate(detect_transfer):
            temp = np.argwhere(neighbor_map[flags[0]] == flags[l])
            if instructions[l] == 0 or instructions[l] == temp:
                instructions[l] = temp
            else:
                contradiction = 1
                return instructions, contradiction
    return instructions, contradiction


def recursive_expansion(working_list, neighbor_map, instructions, contradiction):

    temporal = np.argwhere(working_list != 0)
    allowed_transfer = np.argwhere(instructions != 0)

    for i, j in enumerate(temporal):
        flags = center(working_list, j + 1)
        for l, m in enumerate(allowed_transfer):
            if flags[m] == 0 or flags[m] == neighbor_map[flags[0]][int(instructions[m])]:
                flags[m] = neighbor_map[flags[0]][int(instructions[m])]
            else:
                contradiction = 1

    re_center = np.argwhere(flags == 1)
    working_list = center(flags, re_center[0] + 1)

    return working_list, contradiction


def n_values(lower_b, upper_b):
    n_values = {}
    for j, num in enumerate(np.arange(lower_b, upper_b, 1)):
        # all prime numbers are greater than 1
        if num > 1:
            for i in range(2, num):
                if (num % i) == 0:
                    break
        else:
            print(num)
            n_values[j] = num
    return list(n_values.values())


def prime_check(x):
    for i in range(2, x):
        if (x % i) == 0:
            return 0
    return 1


# Run experiment
n_values = np.arange(3, 30)  # n_values(1,200) # for only prime space size
# Prepare lists and indexize neighbors
results = {}
results_keys = {}
for n in n_values:
    print(n)
    savedata = {}
    for s in range(1, int(n)):
        # print(s)
        neighbor_map = access_neighbor_index(n)
        indexes = generate_distinguishable_indexes(n)
        starting_list = np.arange(1, n + 1, 1)  # original list
        working_list = np.zeros(n)
        working_list[0] = 1
        working_list[s] = int(n / 2)
        contradiction = 0
        for i in range(int(s)):
            # print(i)
            request = generate_instructions(working_list, neighbor_map, contradiction)
            contradiction = request[1]
            if contradiction == 1:
                # print('broke down')
                break
            # print(request[0],working_list)
            request2 = recursive_expansion(working_list, neighbor_map, request[0], contradiction)
            working_list = request2[0]
            contradiction = request2[1]
            if contradiction == 1:
                # print('broke down')
                break
            if len(np.argwhere(working_list != 0)) == n:
                # print(working_list)
                savedata[s] = working_list
                break
    results[n] = len(savedata.keys()) * n * 2
    new = list(savedata.keys())
    results_keys[n] = new

# lists = sorted(results.items())  # sorted by key, return a list of tuples
# x, y = zip(*lists)  # unpack a list of pairs into two tuples

# prime_viz = {}
#
# for index, value in enumerate(x):
#     if prime_check(value) == 1:
#         prime_viz[value] = y[index]
#
# plt.figure()
# plt.plot(x, y)
# plt.scatter(prime_viz.keys(), prime_viz.values())
# # plt.xticks([])
# # plt.yticks([])
# plt.xlabel('Size')
# plt.ylabel('(# possible equilibrium states)')
# plt.title('Partition Function')
# plt.show()

x = list(results_keys.keys())
plt.figure()
for i, j in enumerate(x):
    temp = list(results_keys[j])
    for l in temp:
        plt.plot(j, l, 'rs', linewidth=1, markersize=5.5)

plt.xlabel('Размер кольца')
plt.ylabel('Bозможные местонахождение в равновесии')
plt.title('Bизуализация позиции ближайшего правого соседа')
plt.savefig("местонахождение_в_равновесии.jpeg")
plt.show()


